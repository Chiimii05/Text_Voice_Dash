# streamlit_tts_app.py
# Sintesis de Voz Multiling√ºe con Streamlit
# Requisitos: pip install streamlit edge-tts

import time
import asyncio
import subprocess
import sys
from pathlib import Path
import streamlit as st

# Asegurar que edge-tts est√© instalado
try:
    import edge_tts
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "edge-tts"])
    import edge_tts

# Voces agrupadas
groups = {
    "Espa√±ol": {
        "es-ES-ElviraNeural": "Elvira (es-ES fem.)",
        "es-ES-AlbaNeural": "Alba (es-ES fem.)",
        "es-ES-AlvaroNeural": "√Ålvaro (es-ES masc.)",
    },
    "Ingl√©s (US)": {
        "en-US-JennyNeural": "Jenny (en-US fem.)",
        "en-US-BrandonNeural": "Brandon (en-US masc.)",
    },
    "Ingl√©s (UK)": {
        "en-GB-LibbyNeural": "Libby (en-GB fem.)",
        "en-GB-RyanNeural": "Ryan (en-GB masc.)",
    },
    "Alem√°n": {
        "de-DE-KatjaNeural": "Katja (de-DE fem.)",
        "de-DE-ConradNeural": "Conrad (de-DE masc.)",
    },
    "Portugu√©s": {
        "pt-PT-RaquelNeural": "Raquel (pt-PT fem.)",
        "pt-BR-AntonioNeural": "Ant√¥nio (pt-BR masc.)",
    },
}

# Aplanar opciones con etiqueta de grupo
voice_options = []
for group, voices in groups.items():
    for key, label in voices.items():
        voice_options.append((f"{group} ‚Äî {label}", key))

# Valores por defecto
default_text = "Hola, esto es una prueba de s√≠ntesis de voz."
default_voice = "es-ES-ElviraNeural"

# Configuraci√≥n de p√°gina
st.set_page_config(page_title="TTS Multiling√ºe", layout="centered")
st.title("üéôÔ∏è S√≠ntesis de Voz Multiling√ºe")

# √Årea de texto
text = st.text_area("Introduce tu texto‚Ä¶", value=default_text, height=150)

# Selector de voz
def format_option(option):
    return option[0]

voice_choice = st.selectbox(
    "Elige una voz:",
    options=voice_options,
    format_func=format_option,
    index=[label for label, key in voice_options].index(next(label for label, key in voice_options if key == default_voice))
)[1]

# Bot√≥n de generaci√≥n\if st.button("Generar audio"):
tmp_path = Path("tts_temp.mp3")
with st.spinner("Generando audio‚Ä¶"):
    asyncio.run(edge_tts.Communicate(text=text, voice=voice_choice).save(tmp_path))
ts = int(time.time())
audio_bytes = tmp_path.read_bytes()
st.audio(audio_bytes, format="audio/mp3")
st.success("‚úÖ Audio listo")
st.markdown(f"[‚¨áÔ∏è Descargar MP3](tts_temp.mp3?t={ts})")

# Nota: En despliegues gestionados, revisa el manejo de archivos temporales seg√∫n la plataforma.
